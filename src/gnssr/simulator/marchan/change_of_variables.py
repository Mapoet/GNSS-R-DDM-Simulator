# Generated with Maple

def x_delay_doppler_1(delay, f_d): 
    return ((-math.cos(elevation) ** 2 * v_ty + (-v_tz * math.sin(elevation) - f_d) * math.cos(elevation) + v_ry) * math.sqrt(-v_rx ** 2 * (-4 * math.cos(elevation) ** 3 * delay * h * v_ty * v_tz + (2 * h * delay * (v_ty - v_tz) * (v_ty + v_tz) * math.sin(elevation) + (v_tz + v_ry - v_ty + v_rz) * (-v_tz + v_ry - v_ty - v_rz) * h ** 2 - 4 * delay * f_d * h * v_tz + delay ** 2 * (v_ty ** 2 - v_tz ** 2)) * math.cos(elevation) ** 2 + ((-2 * (v_rz + v_tz) * (v_ry - v_ty) * h ** 2 + 4 * delay * f_d * h * v_ty + 2 * delay ** 2 * v_ty * v_tz) * math.sin(elevation) - 2 * h ** 2 * f_d * (v_ry - v_ty) - 2 * (-2 * v_ty * v_tz + v_rz * (v_ry - v_ty)) * delay * h + 2 * f_d * v_ty * delay ** 2) * math.cos(elevation) + (2 * f_d * (v_rz + v_tz) * h ** 2 + 2 * delay * (f_d ** 2 - v_rx ** 2 - v_ry ** 2 + v_rz * v_tz + v_tz ** 2) * h + 2 * f_d * delay ** 2 * v_tz) * math.sin(elevation) + (f_d ** 2 + v_rz ** 2 + 2 * v_rz * v_tz + v_tz ** 2) * h ** 2 + 2 * f_d * delay * (v_rz + 2 * v_tz) * h + delay ** 2 * (f_d ** 2 - v_rx ** 2 - v_ry ** 2 + v_tz ** 2)) * math.sin(elevation) ** 2) + v_rx ** 2 * (h * (v_ry - v_ty) * math.cos(elevation) ** 3 + (-h * (v_rz + v_tz) * math.sin(elevation) - f_d * h - delay * v_tz) * math.cos(elevation) ** 2 - (v_ry - v_ty) * (delay * math.sin(elevation) + h) * math.cos(elevation) + (delay * f_d + v_rz * h + h * v_tz) * math.sin(elevation) + f_d * h + delay * v_tz)) / v_rx / math.sin(elevation) / ((v_ty ** 2 - v_tz ** 2) * math.cos(elevation) ** 4 + 2 * v_ty * (v_tz * math.sin(elevation) + f_d) * math.cos(elevation) ** 3 + (2 * f_d * v_tz * math.sin(elevation) + f_d ** 2 - v_rx ** 2 - 2 * v_ry * v_ty + v_tz ** 2) * math.cos(elevation) ** 2 - 2 * v_ry * (v_tz * math.sin(elevation) + f_d) * math.cos(elevation) + v_rx ** 2 + v_ry ** 2) 


def x_delay_doppler_2(delay, f_d): 
    return ((math.cos(elevation) ** 2 * v_ty + (v_tz * math.sin(elevation) + f_d) * math.cos(elevation) - v_ry) * math.sqrt(-v_rx ** 2 * (-4 * math.cos(elevation) ** 3 * delay * h * v_ty * v_tz + (2 * h * delay * (v_ty - v_tz) * (v_ty + v_tz) * math.sin(elevation) + (v_tz + v_ry - v_ty + v_rz) * (-v_tz + v_ry - v_ty - v_rz) * h ** 2 - 4 * delay * f_d * h * v_tz + delay ** 2 * (v_ty ** 2 - v_tz ** 2)) * math.cos(elevation) ** 2 + ((-2 * (v_rz + v_tz) * (v_ry - v_ty) * h ** 2 + 4 * delay * f_d * h * v_ty + 2 * delay ** 2 * v_ty * v_tz) * math.sin(elevation) - 2 * h ** 2 * f_d * (v_ry - v_ty) - 2 * (-2 * v_ty * v_tz + v_rz * (v_ry - v_ty)) * delay * h + 2 * f_d * v_ty * delay ** 2) * math.cos(elevation) + (2 * f_d * (v_rz + v_tz) * h ** 2 + 2 * delay * (f_d ** 2 - v_rx ** 2 - v_ry ** 2 + v_rz * v_tz + v_tz ** 2) * h + 2 * f_d * delay ** 2 * v_tz) * math.sin(elevation) + (f_d ** 2 + v_rz ** 2 + 2 * v_rz * v_tz + v_tz ** 2) * h ** 2 + 2 * f_d * delay * (v_rz + 2 * v_tz) * h + delay ** 2 * (f_d ** 2 - v_rx ** 2 - v_ry ** 2 + v_tz ** 2)) * math.sin(elevation) ** 2) + v_rx ** 2 * (h * (v_ry - v_ty) * math.cos(elevation) ** 3 + (-h * (v_rz + v_tz) * math.sin(elevation) - f_d * h - delay * v_tz) * math.cos(elevation) ** 2 - (v_ry - v_ty) * (delay * math.sin(elevation) + h) * math.cos(elevation) + (delay * f_d + v_rz * h + h * v_tz) * math.sin(elevation) + f_d * h + delay * v_tz)) / v_rx / math.sin(elevation) / ((v_ty ** 2 - v_tz ** 2) * math.cos(elevation) ** 4 + 2 * v_ty * (v_tz * math.sin(elevation) + f_d) * math.cos(elevation) ** 3 + (2 * f_d * v_tz * math.sin(elevation) + f_d ** 2 - v_rx ** 2 - 2 * v_ry * v_ty + v_tz ** 2) * math.cos(elevation) ** 2 - 2 * v_ry * (v_tz * math.sin(elevation) + f_d) * math.cos(elevation) + v_rx ** 2 + v_ry ** 2)

def y_delay_doppler_1(delay, f_d):
    return (2 * math.cos(elevation) ** 4 * delay * v_ty * v_tz + ((-delay * v_ty ** 2 + delay * v_tz ** 2) * math.sin(elevation) + h * v_tz ** 2 + (2 * delay * f_d + v_rz * h) * v_tz + h * v_ty * (v_ry - v_ty)) * math.cos(elevation) ** 3 + (((v_ry - 2 * v_ty) * h * v_tz - v_ty * (2 * delay * f_d + v_rz * h)) * math.sin(elevation) - delay * (v_ry + 2 * v_ty) * v_tz + h * f_d * (v_ry - 2 * v_ty)) * math.cos(elevation) ** 2 + ((-delay * v_tz ** 2 - 2 * f_d * h * v_tz - f_d * h * v_rz - delay * (f_d ** 2 - v_rx ** 2 - v_ry * v_ty)) * math.sin(elevation) - h * v_tz ** 2 + (-2 * delay * f_d - v_rz * h) * v_tz - h * (f_d ** 2 + v_ry ** 2 - v_ry * v_ty)) * math.cos(elevation) + v_ry * (delay * f_d + v_rz * h + h * v_tz) * math.sin(elevation) + f_d * h * v_ry + delay * v_ry * v_tz - math.sqrt(-v_rx ** 2 * (-4 * math.cos(elevation) ** 3 * delay * h * v_ty * v_tz + (2 * h * delay * (v_ty - v_tz) * (v_ty + v_tz) * math.sin(elevation) + (v_tz + v_ry - v_ty + v_rz) * (-v_tz + v_ry - v_ty - v_rz) * h ** 2 - 4 * delay * f_d * h * v_tz + delay ** 2 * (v_ty ** 2 - v_tz ** 2)) * math.cos(elevation) ** 2 + ((-2 * (v_rz + v_tz) * (v_ry - v_ty) * h ** 2 + 4 * delay * f_d * h * v_ty + 2 * delay ** 2 * v_ty * v_tz) * math.sin(elevation) - 2 * h ** 2 * f_d * (v_ry - v_ty) - 2 * (-2 * v_ty * v_tz + v_rz * (v_ry - v_ty)) * delay * h + 2 * f_d * v_ty * delay ** 2) * math.cos(elevation) + (2 * f_d * (v_rz + v_tz) * h ** 2 + 2 * delay * (f_d ** 2 - v_rx ** 2 - v_ry ** 2 + v_rz * v_tz + v_tz ** 2) * h + 2 * f_d * delay ** 2 * v_tz) * math.sin(elevation) + (f_d ** 2 + v_rz ** 2 + 2 * v_rz * v_tz + v_tz ** 2) * h ** 2 + 2 * f_d * delay * (v_rz + 2 * v_tz) * h + delay ** 2 * (f_d ** 2 - v_rx ** 2 - v_ry ** 2 + v_tz ** 2)) * math.sin(elevation) ** 2)) / math.sin(elevation) / ((v_ty ** 2 - v_tz ** 2) * math.cos(elevation) ** 4 + 2 * v_ty * (v_tz * math.sin(elevation) + f_d) * math.cos(elevation) ** 3 + (2 * f_d * v_tz * math.sin(elevation) + f_d ** 2 - v_rx ** 2 - 2 * v_ry * v_ty + v_tz ** 2) * math.cos(elevation) ** 2 - 2 * v_ry * (v_tz * math.sin(elevation) + f_d) * math.cos(elevation) + v_rx ** 2 + v_ry ** 2)

def y_delay_doppler_2(delay, f_d):
    return (2 * math.cos(elevation) ** 4 * delay * v_ty * v_tz + ((-delay * v_ty ** 2 + delay * v_tz ** 2) * math.sin(elevation) + h * v_tz ** 2 + (2 * delay * f_d + v_rz * h) * v_tz + h * v_ty * (v_ry - v_ty)) * math.cos(elevation) ** 3 + (((v_ry - 2 * v_ty) * h * v_tz - v_ty * (2 * delay * f_d + v_rz * h)) * math.sin(elevation) - delay * (v_ry + 2 * v_ty) * v_tz + h * f_d * (v_ry - 2 * v_ty)) * math.cos(elevation) ** 2 + ((-delay * v_tz ** 2 - 2 * f_d * h * v_tz - f_d * h * v_rz - delay * (f_d ** 2 - v_rx ** 2 - v_ry * v_ty)) * math.sin(elevation) - h * v_tz ** 2 + (-2 * delay * f_d - v_rz * h) * v_tz - h * (f_d ** 2 + v_ry ** 2 - v_ry * v_ty)) * math.cos(elevation) + v_ry * (delay * f_d + v_rz * h + h * v_tz) * math.sin(elevation) + f_d * h * v_ry + delay * v_ry * v_tz + math.sqrt(-v_rx ** 2 * (-4 * math.cos(elevation) ** 3 * delay * h * v_ty * v_tz + (2 * h * delay * (v_ty - v_tz) * (v_ty + v_tz) * math.sin(elevation) + (v_tz + v_ry - v_ty + v_rz) * (-v_tz + v_ry - v_ty - v_rz) * h ** 2 - 4 * delay * f_d * h * v_tz + delay ** 2 * (v_ty ** 2 - v_tz ** 2)) * math.cos(elevation) ** 2 + ((-2 * (v_rz + v_tz) * (v_ry - v_ty) * h ** 2 + 4 * delay * f_d * h * v_ty + 2 * delay ** 2 * v_ty * v_tz) * math.sin(elevation) - 2 * h ** 2 * f_d * (v_ry - v_ty) - 2 * (-2 * v_ty * v_tz + v_rz * (v_ry - v_ty)) * delay * h + 2 * f_d * v_ty * delay ** 2) * math.cos(elevation) + (2 * f_d * (v_rz + v_tz) * h ** 2 + 2 * delay * (f_d ** 2 - v_rx ** 2 - v_ry ** 2 + v_rz * v_tz + v_tz ** 2) * h + 2 * f_d * delay ** 2 * v_tz) * math.sin(elevation) + (f_d ** 2 + v_rz ** 2 + 2 * v_rz * v_tz + v_tz ** 2) * h ** 2 + 2 * f_d * delay * (v_rz + 2 * v_tz) * h + delay ** 2 * (f_d ** 2 - v_rx ** 2 - v_ry ** 2 + v_tz ** 2)) * math.sin(elevation) ** 2)) / math.sin(elevation) / ((v_ty ** 2 - v_tz ** 2) * math.cos(elevation) ** 4 + 2 * v_ty * (v_tz * math.sin(elevation) + f_d) * math.cos(elevation) ** 3 + (2 * f_d * v_tz * math.sin(elevation) + f_d ** 2 - v_rx ** 2 - 2 * v_ry * v_ty + v_tz ** 2) * math.cos(elevation) ** 2 - 2 * v_ry * (v_tz * math.sin(elevation) + f_d) * math.cos(elevation) + v_rx ** 2 + v_ry ** 2)
